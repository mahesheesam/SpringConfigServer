import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;

public class PreferenceUtilTest {

    private static final Logger log = LoggerFactory.getLogger(PreferenceUtilTest.class);

    private FileFormat fileFormat;
    private Set<String> fileFormatSet;

    @BeforeEach
    public void setUp() {
        fileFormat = mock(FileFormat.class);
        fileFormatSet = new HashSet<>();
    }

    @Test
    public void testExtractedWithDefaultValues() {
        // Setup mock behavior
        Mockito.when(fileFormat.getDefaultValues()).thenReturn(mock(Options.class));
        Mockito.when(fileFormat.getDefaultValues().getCheckListOptions()).thenReturn(Arrays.asList("option1", "option2"));
        Mockito.when(fileFormat.getDefaultValues().getRadioButtonOptions()).thenReturn(Arrays.asList("radio1", "radio2"));

        // Call the method
        PreferenceUtil.extracted(fileFormat, fileFormatSet);

        // Validate the results
        assertTrue(fileFormatSet.contains("option1"), "Set should contain 'option1'");
        assertTrue(fileFormatSet.contains("radio2"), "Set should contain 'radio2'");
    }

    @Test
    public void testExtractedWithBatchValues() {
        // Setup mock behavior
        Mockito.when(fileFormat.getBatch()).thenReturn(mock(Options.class));
        Mockito.when(fileFormat.getBatch().getRadioButtonOptions()).thenReturn(Arrays.asList("batchRadio1", "batchRadio2"));

        // Call the method
        PreferenceUtil.extracted(fileFormat, fileFormatSet);

        // Validate the results
        assertTrue(fileFormatSet.contains("batchRadio1"), "Set should contain 'batchRadio1'");
        assertTrue(fileFormatSet.contains("batchRadio2"), "Set should contain 'batchRadio2'");
    }

    @Test
    public void testExtractedWithRailsValues() {
        // Setup mock behavior
        Mockito.when(fileFormat.getRails()).thenReturn(mock(Options.class));
        Mockito.when(fileFormat.getRails().getRadioButtonOptions()).thenReturn(Arrays.asList("railsRadio1", "railsRadio2"));

        // Call the method
        PreferenceUtil.extracted(fileFormat, fileFormatSet);

        // Validate the results
        assertTrue(fileFormatSet.contains("railsRadio1"), "Set should contain 'railsRadio1'");
        assertTrue(fileFormatSet.contains("railsRadio2"), "Set should contain 'railsRadio2'");
    }

    @Test
    public void testAddToHashSetWithNonEmptyList() {
        Set<String> set = new HashSet<>();
        List<String> list = Arrays.asList("item1", "item2");

        PreferenceUtil.addToHashSet(set, list);

        assertEquals(2, set.size(), "Set should contain 2 items");
        assertTrue(set.contains("item1"), "Set should contain 'item1'");
        assertTrue(set.contains("item2"), "Set should contain 'item2'");
    }

    @Test
    public void testAddToHashSetWithEmptyList() {
        Set<String> set = new HashSet<>();
        List<String> list = Collections.emptyList();

        PreferenceUtil.addToHashSet(set, list);

        assertTrue(set.isEmpty(), "Set should be empty");
    }

    @Test
    public void testSplitPartitionsWithValidInput() {
        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
        int batchSize = 2;

        List<List<Integer>> partitions = PreferenceUtil.splitPartitions(list, batchSize);

        assertEquals(3, partitions.size(), "There should be 3 partitions");
        assertEquals(Arrays.asList(1, 2), partitions.get(0), "First partition is incorrect");
        assertEquals(Arrays.asList(3, 4), partitions.get(1), "Second partition is incorrect");
        assertEquals(Collections.singletonList(5), partitions.get(2), "Third partition is incorrect");
    }

    @Test
    public void testSplitPartitionsWithEmptyList() {
        List<Integer> list = Collections.emptyList();
        int batchSize = 2;

        List<List<Integer>> partitions = PreferenceUtil.splitPartitions(list, batchSize);

        assertTrue(partitions.isEmpty(), "Partitions should be empty for an empty list");
    }

    @Test
    public void testSplitPartitionsWithInvalidBatchSize() {
        List<Integer> list = Arrays.asList(1, 2, 3);

        log.error("List cannot be null and batchSize must be greater than 0");
        List<List<Integer>> partitions = PreferenceUtil.splitPartitions(list, 0);

        assertTrue(partitions.isEmpty(), "Partitions should be empty for invalid batch size");
    }
}
